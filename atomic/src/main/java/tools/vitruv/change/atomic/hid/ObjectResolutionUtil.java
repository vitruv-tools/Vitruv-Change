package tools.vitruv.change.atomic.hid;

import static com.google.common.base.Preconditions.checkState;
import static edu.kit.ipd.sdq.commons.util.org.eclipse.emf.ecore.resource.ResourceUtil.getFirstRootEObject;

import edu.kit.ipd.sdq.activextendannotations.Utility;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * Utility class to resolve URIs for {@link EObject}s.
 */
@Utility
public class ObjectResolutionUtil {
  private ObjectResolutionUtil() {
    // empty constructor
  }

  /**
   * Returns a hierarchic URI fragment for the given {@link EObject}. Its use case is to resolve the
   * same object in different instances of the same resource loaded into different resource sets.
   * It is essential that the resources must be in the exact same state, and it is <b>not</b>
   * guaranteed that using the returned fragment objects can always be resolved, but at least 
   * it gives the chance to do so whenever the ordinary URI delivered by EMF is not sufficient.
   * So use this method with care!
   * 
   * <p>Metamodels may use XMI IDs, which are used by EMF as the URI fragment of objects 
   * and generated anew during each load of the same resource.
   * Hence, these URI fragments cannot be used to resolve the same object
   * across different resource sets containing a loaded instance of the same resource.
   * The URI fragment generated by this method depends on the fragment given by
   * {@link EcoreUtil#getRelativeURIFragmentPath} and thus does circumvent the problem of XMI IDs.
   * 
   * <p>In consequence, for an object <code>objectInResourceSet1</code> 
   * contained in a {@link ResourceSet} <code>resourceSet1</code>, it should be possible 
   * to resolve it in another {@link ResourceSet} <code>resourceSet1</code>,
   * even when its resource uses XMI IDs:
   * <pre>
   * <code>
   *    assertTrue(resourceSet1.getEObject(EcoreUtil.getURI(objectInResourceSet1), false))
   *    var objectInResourceSet2 = resourceSet2.getEObject(
   *      getHierarchicUriFragment(objectInResourceSet1), false)
   * </code>
   * </pre>
   *
   * @param object the {@link EObject} to get a hierarchic URI fragment for
   * @return a hierarchic URI fragment for the given {@link EObject} 
   */
  public static String getHierarchicUriFragment(EObject object) {
    final var resource = object.eResource();
    var rootElementIndex = 0;
    
    EObject resourceRoot = null;
    if (resource.getContents().size() <= 1) {
      resourceRoot = getFirstRootEObject(object.eResource());
    }
    else {
      // move up containment hierarchy until some container is one of the resource's root elements
      resourceRoot = object;
      while (resourceRoot != null
        && (rootElementIndex = resource.getContents().indexOf(resourceRoot)) == -1) {
        resourceRoot = resourceRoot.eContainer();
      }
      checkState(resourceRoot != null,
          "some container of %s must be a root element of its resource", object);
    }

    final var fragmentPath = EcoreUtil.getRelativeURIFragmentPath(resourceRoot, object);
    if (fragmentPath.isEmpty()) {
      return "/" + rootElementIndex;
    } else {
      return "/" + rootElementIndex + "/" + fragmentPath;
    }
  }
}
